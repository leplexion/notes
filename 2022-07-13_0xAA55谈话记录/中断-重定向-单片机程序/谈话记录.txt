[a5] 这个资料[en.CD00171190]描述了芯片的包装样式，中断表，外设，寄存器

    你现在看不懂

    但, 我可以大致告诉你单片机开发的思路

    这个zip里面的PDF是拿来当字典用的

[xr] 中断到底是什么意思

[a5] 
    中断：CPU的一个功能
    特定条件满足时
    不管你当前程序运行得咋样
    立即暂停运行
    然后跳转到特定的 中断函数 里面去运行。

[xr]
    我之前看过类似的描述, 所以当它是
        try 
        catch
        throw
    一类机制的实现

[a5] try catch这一类是软件实现，而中断是硬件实现。

    举个例子：定时器中断。你设置定时器每一毫秒触发一次，
    
    并且启用了它的中断；然后启动定时器。

    此时，你运行以下的C程序：
    // ----------------------------------
    void interrupt 定时器中断函数()
    {
        串口print("1");
    }

    int main()
    {
        设置定时器中断();
        while(1)
        {
            //死循环，啥也不做
        }
        return 0;
    }
    // ----------------------------------

    注意其中的interrupt关键字，它告诉C语言：这是一个中断函数。

    声明外加函数实现，因为它有花括号 {}
    
    函数的实现是：调用“串口print()”参数是字符串"1"

[xr] 这个中断是不是会被放在额外的区块..

[a5] 你说的是中断函数还是中断设备还是中断请求号？ 

[xr] 我说的是编译结果, 我把情况带入到win exe文件了

[a5] 情况没差，因为Linux的ELF等同于Windows的EXE DLL,

    编译结果里，你得到的程序是一个Linux的ELF文件
    
    然后使用一个“抽剥”的程序，把ELF里面没用的内容去掉，只留下单片机认的纯二进制

    顺带一提，Windows上也有“针对EXE的‘抽剥’程序”
    
    可以提取EXE里面的代码和数据（所谓“数据”就是你的常量和全局变量那些）

[xr] 然后a5, 你是能徒手写pe文件从内存中展开的吧

[a5] 能。

[xr] 如果是抽离的, 应该是.. 用了相对偏移的吧

[a5] 是应用了偏移。

    由于单片机在从烧录好的ROM上读取指令的时候
    
    机器本身设置ROM的地址为某个特定地址

    所以只需要在“抽剥”的时候
    
    --- 让代码知道自己在哪个地址被加载运行即可。 ---

[xr] 之前摸了一下这个反射注入哈,

    然后写了笔记, 之前没精力摸到了

[a5] 我觉得注入的话没必要弄那么费劲, 首先我没必要自己展开

    我直接用“抽剥”的方式, 

    把代码放到最开头，数据放到结尾

    然后编译出EXE或者DLL或者ELF后，直接抽剥出bin

    就可以拿来做shellcode了

    那么你现在知道单片机运行的ROM是抽剥好了的shellcode

    也就是：只有指令（已完成重定向）和数据

    指令和数据一开始，在单片机ROM里；
    
    单片机上电后，
    
    你的单片机工具包帮你整合了一套初始化代码；
    
    这套初始化代码把数据复制到RAM里，
    
    这样你就能写你的全局变量了，然后它调用你的main()

[xr] 你这么重复了一遍.. 我就记住了

    重定向那一部分, 还是比较模糊

[a5] 重定向整不清楚是吧？

    我抛开PE的内容，不教你EXE DLL的重定向

    就教你：为何要有重定向这一步骤, 行不

    首先：当你运行一个32位的Windows EXE的时候

    假设你这个EXE是你自己写的，

    哦对了顺带问你一个问题：

    你有没有试过用记事本打开EXE？

    用记事本打开EXE后，最开头你会看到一个 'MZ'

    然后一堆乱码，然后 PE, 再往后是 .text .data .rdata .reloc .bss 这些

[xr] 这个知道, dos结构, 然后nt header, 接着 这些节段 的索引

[a5] 那好：

    当你的32位 EXE 运行的时候，你的PE文件被加载到 0x400000 这个地址。

    当你把 0x400000 当做字节指针，从后读出各种字节，打印出来看，
    
    你会看到 'MZ' ，PE，.text .data 这些 以及若干乱码。

[xr] header 还有 各种表里 都记录了 区段展开与对齐的方式

[a5] 嗯，因为EXE 为了压缩体积，它是紧凑存储的

    但加载到内存后，为了速度（内存是 4kb 一个页）

    EXE 的内容需要被展开。

    先不说这个，我就说：假设EXE文件它自己内部就是按 4KB 对齐的

    那么展开后也一样，这一点你也是理解的

    （展开后因为还是4KB对齐，因此地址不变）

[xr] 这个我真没想过哎, 这个结构字段很多..我有时候直接懵了

[a5] 那么，你写这么一个程序：
    // ----------------------
    int asdf = 3;

    int main()
    {
        asdf = 10;
        printf("%d\n", asdf);
        return 0;
    }
    // ----------------------

    那么，这个程序如何执行“asdf = 10”这个语句？

    它如何知道asdf 被存储在哪？

[xr] 额...我最盲区的部分就是, 数据存储方式, 哪怕知道代码在哪里,

    如果是汇编.. 似乎是自定义的 section, 但是我是懵的...

    数据段跟代码段是不是在一起的

    我都不清楚

[a5] 当你写 int asdf = 3; 的时候：

    C语言编译器创建一个section名为 .data 意思是数据
    
    然后，你所有的全局变量都在这里面，紧凑存储

    比如你另有别的 xxx.c 文件它有个 int fdsa = 4;


    那么你的整个程序的数据段 .data 就存储了 03 00 00 00 04 00 00 00 这8个字节

    一个是 asdf ，3，另一个是fdsa，4

    它根据一个计算好的地址，找出 asdf 的值，赋值为 10

    再根据一个计算好的地址找出字符串 "%d\n" 的地址，和刚刚的 asdf 的值，拿来调用 printf

[xr] 那, 某个位置调用它的地址, 应该是相对这条指令的还是这个module的

    就mz开头的位置, x86的寻址我不了解, 咳咳...

[a5] 是绝对地址。

[xr] 嗯呐...绝对地址有点夸张的感觉..

[a5] 比如我 EXE 在 0x400000 这个地址，

    那我的 .text 大概率在 0x401000 这个地址

    我的 .data 大概率在 0x402000 这个地址

    那我的 asdf 就在 0x402000 这里

    我的 int main() 的指令地址大概在 0x401XXX 这个地址，
    
    然后我的 printf() 也在差不多这个地址，
    
    而 printf 是 C 标准库的东西，
    
    它自己本身并不是魔法，而是靠 Windows 的 API 来写 Console

    因为是绝对地址，
    
    所以才需要“重定向”，
    
    那就是：如果我程序不被加载到 0x400000 
    
    （比如 DLL 的地址就肯定不是 0x400000 ，它甚至每次被加载的地址都不一样）

    那么：

    负责重定向的程序需要根据重定向表，
    
    知道你汇编指令在哪些地方使用了绝对地址的指针，
    
    这个指针的值并不是绝对地址，
    
    而是相对于我 EXE（或DLL）文件开头的地址的

    我把这个地址，加上我EXE、DLL的加载地址，不就是正确的绝对地址了吗？

    所以这就是重定向。

    虽然实际上，
    
    CPU是有很多相对寻址的指令的，
    
    但因为之前我提到一点：
    
    .text和.data在EXE文件形式的时候它可能是紧凑存储的，
    
    但EXE 加载到内存后它会展开，那么 .text 和 .data 存储位置的间隔可能会扩大，
    
    那么即使是相对地址，那也要重定向。

[xr] 稍等我多看几眼, 重定向表, 记录的是, 调用位置的指针?

[a5] 是的。它既可以是变量指针，也可以是函数调用指针

[xr] 等下...

    那它是不是在加载之时, 把那些需要的指针全部重写一遍

[a5] 对。

    我告诉你的这个知识，对于你来说是不是足够重磅，足够直击你的内心

[xr] ...是是, 您超级性感的

[a5] 那么：

    单片机的“抽剥”工具链，
    
    做的就是这件事：
    
    抽剥出 .text、.data的内容，
    
    然后根据你设置的“程序加载地址”做重定向。

    最后得到纯粹的代码和数据。存储到一起，变为二进制文件.bin。烧录到单片机

[xr] ... 咳咳, 今天专门创了个文件夹0xaa55, 看来笔记有的放了

[a5] 中断那道题的答案

    “设置定时器中断();”函数结束后，

    这个单片机就会每毫秒都执行一次“定时器中断函数()”，从串口输出一个 1

    并且是在 while(1) 的过程中执行

[xr] 它会返回嘛

[a5] 会。返回后， while(1)继续执行。

[xr] 那就是也可以不返回咯

[a5] 你说的“不返回”指的是你不写 return 吗？

[xr] [图:中断不返回.png]

[a5] 你说的是你不 ret

    其实中断函数的“返回指令”是不同于一般的返回指令的，
    
    在 x86 是 iret 指令

    因为单片机的 int main() 其实也是一个中断处理函数

    中断理由是“单片机入口”

    硬件上电后，觉得它可以开始执行了，于是触发中断。导致处理器被跳转到 int main() 的位置。

    同理，你的定时器被设置为每 1ms 触发一次。
    
    触发的时候，你的硬件觉得应该处理定时器中断了。
    
    于是它不管你处理器现在在执行啥，
    
    它直接把处理器的执行地址设置为定时器中断函数的地址，
    
    就跳进去执行了

    中断返回指令执行后，CPU回到中断前的位置继续执行

[xr] 中断是谁控制的, 这个问题会不会很sb, 

    突然跳转到不该正常下一条指令的地方

    是寄存器嘛

    某个寄存器状态被什么零件写了

[a5] “可编程中断控制器”，PIC

    这不仅单片机上有，咱的 x86 、x64电脑里也有

    x86、x64电脑里的更强，
    
    是“高级可编程中断控制器” APIC 
    
    可以发送“处理器间中断”，
    
    由一个核心捅开另一个核心。

    此外，你知道处理器它有个寄存器叫“指令指针寄存器”吧，
    
    x86是 eip，x64是rip，ARM是PC

    这个寄存器决定了处理器从哪里读指令出来执行。

[xr] 你一定要长命百岁啊

[a5] 另外，硬件并不知道你哪个函数是干什么中断的，需要你软件告诉硬件哪个中断是谁的

    因此：有个叫“中断表”的东西，存储在一个固定的地址，或者，x86的话，在PIC、APIC里可以调这个地址。

    然后，硬件按照中断号对应中断表，进行一个函数指针的调用

    比如我除零异常中断是0号，我NMI中断是1号，我定时器中断是2号，我DMA中断是3号

    那就按照这样，用函数指针数组，来做中断表，然后单片机的“抽剥”可以确保这个中断表在 bin 的最开头

    烧录到ROM里的时候单片机直接从ROM最开头找中断表，
    
    根据中断表找到你的“单片机初始化”函数
    
    （这个函数把你的.data数据从ROM拷贝到RAM，使其变得可写）
    
    然后执行。“单片机初始化”函数则用一个 while(1) 循环调用你的 main() 函数。

    x86、x64虽然复杂很多，
    
    但大体上依然还是这套逻辑。
    
    其中的 BIOS 的开机自检，
    
    就类似于你的“单片机初始化”函数，
    
    然后它从硬盘引导。
    
    它既可以从硬盘找UEFI文件加载执行，
    
    也可以按照MBR扇区来执行，
    
    后者虽说因为安全问题是被淘汰的东西。

    再往下的就先不再继续介绍了，
    
    你今天就负责把我说的“重定向”的知识巩固了

[xr] 1