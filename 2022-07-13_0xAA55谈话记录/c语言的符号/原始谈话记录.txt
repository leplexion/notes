虚荣的倒影 2022/7/12 20:02:25

    a5,如果要用c cpp写一个内容很多的dll的话, 文件该怎么组织呢?
    还有就是, 用vs编译o, 也能加到gcc工程里编译吧?
    总觉得用vs不太方便挪
    好像整出静态链接库然后最终编译出一个动态链接库比较合适是嘛...

0xAA55 姐介 2022/7/12 21:57:33

    MSVC 编译出来的 obj 是微软魔改 coff 格式，gcc 编译出来 .o 是 elf 格式，无法通用。
    回复: 
        "a5,如果要用c cpp写一个内容很多的dll的话, 文件该怎么组织呢"
    具体描述。

虚荣的倒影 2022/7/12 21:58:19

    比如我要把一些 winapi 分割成
    封装后分隔成一块块的 o文件 出来
    可能有部分功能更新比较频繁
    那另一些就不重复编译了，需要的时候链接一下
    不知道这个思路有毛有毛病
    弄出导出表这个我倒测成功了

0xAA55 姐介 2022/7/12 21:59:29
    回复: "好像整出静态链接库然后最终编译出一个动态链接库比较合适是嘛..."

    Win32 DLL 的编译过程和编译 EXE 基本一样，不同地方是你会希望你的 DLL 能有个导出表。
    因此你需要使用 _declspec(dllexport) 来导出变量、函数、类的符号，或者使用 .def 文件。

0xAA55 姐介 2022/7/12 22:00:39
    回复: "不知道这个思路有毛有毛病"

    你这个思路，我可否理解为“我逆向我自己”

虚荣的倒影 2022/7/12 22:01:10
    。。我被脚本惯坏了都
    c系如果不能直接f5我就很忧郁。。

0xAA55 姐介 2022/7/12 22:01:44
    f5是干啥

虚荣的倒影 2022/7/12 22:01:54
    编译调试啥的。。，

0xAA55 姐介 2022/7/12 22:02:07
    F5 在 IDA 里面是一键逆向出源码。

虚荣的倒影 2022/7/12 22:02:13
    我c不太熟悉
    所以，如果写大了就很混乱
    但是有些内容如果能编译出来
    到时候就不用再多调试了。。
    我是这么想的

0xAA55 姐介 2022/7/12 22:03:29
    不编译出来，而是当成小工程调试稳定后，大工程可以直接用，不用再在调试大工程的时候去关心小工程的实现了。
    你是想这样。

虚荣的倒影 2022/7/12 22:03:36
    是的。。。
    你这样描述就很清晰了。。

0xAA55 姐介 2022/7/12 22:03:56
    这就涉及到一个基础的概念了，啥叫“符号”
    之前群里有人说“printf不用声明、不用包含 stdio.h 就能直接用”
    首先你知道 lib 是多个 obj 的集合
    你的每个 .c .cpp .asm 编译出来是 .obj
    或者 gcc 的 .o
    在这个基础知识上面
    我给你讲链接器的原理

虚荣的倒影 2022/7/12 22:25:06
    好的老板

0xAA55 姐介 2022/7/12 22:29:46
    
    我给你讲链接器的原理
    那这样。首先你知道 obj 是中间文件
    这个中间文件最早是用来存储编译好的二进制片段和数据片段的

虚荣的倒影 2022/7/12 22:30:28
    哎, 就是汇编编译出来的二进制文件, 到可执行文件之前的部分咯

0xAA55 姐介 2022/7/12 22:30:38
    这里的二进制片段就是你每个函数的 CPU 指令，数据是你的常量比如字符串，或者全局变量

    回复: "哎, 就是汇编编译出来的二进制文件, 到可执行文件之前的部分咯"
    对。

虚荣的倒影 2022/7/12 22:31:19
    继续啊大佬

0xAA55 姐介 2022/7/12 22:31:30
    二进制指令从变量里读取数据的时候，是需要知道这个变量的内存地址的。同理，二进制指令调用二进制的函数的时候，也是需要知道这个函数的地址的。

0xAA55 姐介 2022/7/12 22:31:51
    这个你应该知道，感觉你玩过 OD，听过 IDA

虚荣的倒影 2022/7/12 22:31:54
    嗯呐
    IDA之前问过你反编译

0xAA55 姐介 2022/7/12 22:32:19
    那么，作为中间文件，也就是二进制片段，它不管是函数的地址还是变量（数据）的地址都是不确定的
    只有在最后，组装为一个完整的程序的时候，它应该被存储在哪个地址，才能得到确定。
    这个“组装”的过程就是链接器的过程。

0xAA55 姐介 2022/7/12 22:33:00
    好，那么，思考一下

虚荣的倒影 2022/7/12 22:33:16
    思考啥子...

0xAA55 姐介 2022/7/12 22:33:19
    假设我有个函数要调用 printf 这个函数
    可是编译器不知道 printf 这个函数的最终地址
    它应当如何生成二进制指令呢？

虚荣的倒影 2022/7/12 22:33:47
    符号是写在o里的么

0xAA55 姐介 2022/7/12 22:33:55
    你回答我这个问题先。

虚荣的倒影 2022/7/12 22:34:09
    预留一个空位么

0xAA55 姐介 2022/7/12 22:34:12
    是的。
    就会变成 call 0x00000000
    然后在 obj 的重定向表里面，记录这里有个空位，它是 printf 这个函数的地址。
    链接器要做的就是把这些空位给填了。

0xAA55 姐介 2022/7/12 22:35:32
    那么这个时候，obj 中的这些空位的“名字”，就是“符号”的概念了。

虚荣的倒影 2022/7/12 22:35:44
    涨姿势

0xAA55 姐介 2022/7/12 22:36:39
    32 位情况下 C 语言的行为就是给_cdecl风格函数名字加上 _ 前缀，_stdcall风格函数额外追加参数个数
    64 位的话不需要 _ 前缀。
    C++ 的行为就比较奇葩了。因为 C++ 允许函数重载，比如我有 int max(int a, int b); 和 float max(float a, float b);
    这两个函数应当同时存在，不能有符号冲突。所以 C++ 会把参数类型也编码进去

虚荣的倒影 2022/7/12 22:38:24
    这...我认为简直是屎上加屎...

0xAA55 姐介 2022/7/12 22:38:25
    比如：

    ?func@@YAXXZ
    这个符号的含义是：
    void _cdecl func(void);

    这是 MSVC 的行为。而 GCC 的“符号装饰”则是完全不同的另一套规则。

0xAA55 姐介 2022/7/12 22:39:07
    回复: "这...我认为简直是屎上加屎..."
    虽然屎，但是这样可以把命名空间、类名、函数名、参数类型等都搞到符号里面去。

    这就导致 C++ 如果报了符号的错，那就非常长了
    图: 1-符号编译报错

    我从这些符号里，就可以看出来是 C++ 哪块出现了链接问题

    但这种符号装饰确实会吓跑新人。
    图: 2-与冰岚时空的聊天截图 / 3-与冰岚时空的聊天截图


虚荣的倒影 2022/7/12 22:44:03
    我看见vs的设置面板就腿软咳咳


虚荣的倒影 2022/7/12 22:41:50
    ?func@@YAXXZ
    这每一个符号什么意思呢a5
    ? 
    @@
    YAXXZ

0xAA55 姐介 2022/7/12 22:48:26

    问号表示它是 C++
    @@  表示后面是 参数列表、函数类型、返回值类型
    YA  表示 函数类型 为 _cdecl
    X   表示 函数返回类型 是 void
    XZ  表示 函数参数列表 是 (void)


0xAA55 姐介 2022/7/12 22:48:59
    图: 4-a5用vb实现的符号编译器
    我用 VB 写过这个符号的翻译器

虚荣的倒影 2022/7/12 22:49:45
    天哪.
    a5这种时候超级帅,,

0xAA55 姐介 2022/7/12 22:50:54
    那么符号的情况也说明清楚了。接下来给你解释为啥 C 语言不用包含头文件，不用声明函数，就可以直接调用 printf
    首先，没有声明的函数会被默认为是 int xxx(); 类型，其中参数如果你填多少个，它就会传递多少个。
    其次，编译出来后，你的 obj 会导入一个 _xxx 的符号。那么在 printf 的情况下，导入的符号就是 _printf 了。

虚荣的倒影 2022/7/12 22:52:55
    没有声明的函数, 是在链接阶段报错的?


0xAA55 姐介 2022/7/12 22:54:24

    链接器在处理你的 obj 的时候，发现你的 obj 导出了 _main 符号，然后导入了 _printf 符号。

    此时链接器会遍历所有的别的 obj 或者 lib，查找任何一个能导出 _printf 的 obj。注意 lib 就是一堆 obj 的集合。

        如果找到了 _printf 符号的导出，则可以完成链接；
        如果找到了多个 _printf 的导出，则报错：符号冲突；
        如果没有找到 _printf 的导出，则报错：符号未解决。



0xAA55 姐介 2022/7/12 22:57:05
    然后 MSVC 默认会链接 C 运行库，这个运行库提供了 _printf 符号的导出，并且导入 _main 符号。

    MSVC 的链接器默认以 mainCRTStartup 为入口点，这个符号的依赖存在；
    然后 mainCRTStartup 会调用 _main，导致对 _main 符号的依赖；
    _main 里面调用 _printf 导致对 _printf 的依赖。

    链接器把所有的符号依赖关系理清楚以后，就可以生成 exe 了。


虚荣的倒影 2022/7/12 22:56:28
    没有声明就调用的函数
    在obj中视为要导入的符号
    声明了的函数视为导出的符号
    这个意思嘛?

0xAA55 姐介 2022/7/12 22:57:18
    不是。

    你写了哪些函数的实现，哪些函数自然就会导出其对应的符号。比如你写了 int main() 里面的内容，那么你就会导出 _main 符号。
    使用 static 关键字可以不让编译器导出符号。 static int foo() 声明的函数 foo 不会导出符号，只在这个 .c 内部可以使用。

    C 运行库帮你实现了 printf，它自然就会导出 _printf 符号。
    你调用了 printf，你就会导入 _printf 符号。
    C 语言使用关键字 extern 来声明一个符号是外部导入的。

    定义变量，定义函数 = 导出符号。
    使用别的obj的变量，调用别的obj的函数 = 导入符号。

虚荣的倒影 2022/7/12 23:00:50
    运行库里的符号是不用extern的吗

0xAA55 姐介 2022/7/12 23:01:10
    extern 是可以省略的。

虚荣的倒影 2022/7/12 23:01:27
    ...这个有点过分了

0xAA55 姐介 2022/7/12 23:01:28
    但是有一种情况不能省略

虚荣的倒影 2022/7/12 23:01:38
    嗯?

0xAA55 姐介 2022/7/12 23:01:41
    从别的 obj 导入变量的时候不能。

0xAA55 姐介 2022/7/12 23:02:03
    别的obj：

    int asdf = 3;

    你如果要操作这个 asdf，你就需要这样声明：

    extern int asdf;

虚荣的倒影 2022/7/12 23:02:10
    int test(void);

    int test(void) {
    }

    这种两处声明是因为顶上的函数不能调用底下的函数么?

0xAA55 姐介 2022/7/12 23:03:21
    回复: "
        int test(void);

        int test(void) {
        }
    "

    1、声明函数。意思是这个函数存在，但是它既可以在这个 obj里，也可以在别的 obj里。
    2、声明函数的实现。意思是我定义函数的内容了。我导出这个函数的符号。

0xAA55 姐介 2022/7/12 23:03:29
    回复: "这种两处声明是因为顶上的函数不能调用底下的函数么?"
    不是。

    能调用，但是因为没有声明，所以函数类型被暂定为 int xxx();

    而如果你不想返回 int，你想返回一个结构体或者 float，那么这种暂定的声明会导致调用者错误处理函数的返回值。


虚荣的倒影 2022/7/12 23:05:10
    之前有给别人看过一个代码, 是调用struct的地方上方没有定义struct发生错误
    函数是没有这样的顺序限制么

0xAA55 姐介 2022/7/12 23:05:35

    不。
    我每次正要给你从根本上解释清楚为啥你会陷入这个误区，
    你就给我追问一个问题来了。


虚荣的倒影 2022/7/12 23:06:22
    大佬你先。。

0xAA55 姐介 2022/7/12 23:06:24
    之前给你提到过
    C 语言在语法层面，也就是编译器的层面上
    在你没有声明函数就使用的时候，编译器会自动生成一个 int xxx(); 类型的函数，替你声明。
    仅此而已。
    这个是语法特性，和链接器啥的符号啥的没有任何关系。
    C++ 是不允许这么做的。
    C++ 所有的函数都必须声明。
    C++ 声明函数的时候，有两种声明方法，一种是普通的声明方法，另一种是“C符号风格”声明方法

0xAA55 姐介 2022/7/12 23:08:39
    后者会导致符号修饰从 ?xxx@@YAXXZ 变为 _xxx

虚荣的倒影 2022/7/12 23:08:42
    extern "C"是这个意思吗

0xAA55 姐介 2022/7/12 23:08:45
    是的
    这个东西，就是为了让 C++ 消除符号修饰。
    导出的东西也用这个消除；导入的东西也用这个消除。

虚荣的倒影 2022/7/12 23:10:11
这个导入和导出如果统一一下命名前缀就好了。。。

0xAA55 姐介 2022/7/12 23:10:33
    // ------------------------------
    int test(void); // 声明函数原型，使调用过程中，调用者知道如何正确传参和取回返回值。

    int test(void) // 声明函数行为。这个声明的存在，意味着这个函数从这个 obj 导出。
    {
    }
    
    用这种方式导入导出符号就行了。我调用函数表示我导入，我实现函数表示我导出。

    // ------------------------------
    int test2(void); // 声明函数原型，使调用过程中，调用者知道如何正确传参和取回返回值。

    int test(void) // 声明函数行为。这个声明的存在，意味着 test 这个函数从这个 obj 导出。
    {
        return test2(); // 调用一个只有原型的函数意味着从外部导入这个函数的符号。
    }

    // ------------------------------
    在汇编语言，导入导出的修饰是统一的：

    global 导出
    extern 导入

    // ------------------------------
    好，你现在已经知道静态链接是怎么回事了
    接下来告诉你动态链接。

    动态链接，就是一个 DLL 它也有重定向表，它也能导出函数，导入函数，关键就是这个过程发生在你加载 DLL 的过程中。
    你通过链接器参数告诉你的链接器：我要编译为一个 DLL。
    你的链接器就会给你的 DLL 生成一个导出表，所有你的 obj 导出的全部符号里面，你希望这个 DLL 导出的符号，都放到了这里，做一个统一的表，说明你的 DLL 提供这些符号。

    这里面，MSVC 使用 _declspec(dllexport) 这个前缀修饰一个符号，表示这个符号是希望 DLL 导出的。

    如果你提供了 DEF，那么符号具体长啥样（是否有修饰等）由你的 DEF 决定；否则一律按 C++ 风格修饰（变成 ?xxx@@YAXXZ）

虚荣的倒影 2022/7/12 23:18:11
    又来个DEF...

0xAA55 姐介 2022/7/12 23:19:25
    def 就是个文本文件，提供一个符号列表，一行一个符号。开头两行写“LIBRARY”“EXPORTS”之后就一行一个符号了。除了符号，你还可以定义序号。

虚荣的倒影 2022/7/12 23:19:36
    嗯呐
    然后这个def也是给链接器看的咯?


0xAA55 姐介 2022/7/12 23:20:09
    对。

虚荣的倒影 2022/7/12 23:20:40
    a5这趟可比我看一堆没用的文章给力多了..

    
0xAA55 姐介 2022/7/12 23:20:44
    当你需要使用这个 DLL 作为你的库，有两种方法，
    
    一种是 DLL 在编译的时候，链接器会给你附赠一个 .lib 文件，你在使用的时候，导入这个附赠的 .lib 文件，
    然后使用 __declspec(dllimport) 修饰你要导入的符号名。
    这会导致你的程序一被加载就会被 Windows 自动加载你针对的那个 DLL 并自动帮你完成重定向。

    另一种是使用 kernel32.dll 提供的 LoadLibrary 函数，加载一个 DLL，
    然后使用 GetProcAddress 直接按符号或者序号取得 DLL 的符号对应的地址。

    这个地址如果是函数，它就是函数地址；如果是变量，它就是变量地址。

    在 C 语言，你通过编写函数指针这样的东西来调用特定地址上的函数。

虚荣的倒影 2022/7/12 23:22:59
    got it  

0xAA55 姐介 2022/7/12 23:23:00
    使用这个“附赠的.lib”会导致你的程序拥有一个导入表。
    使用 LoadLibrary 则不需要导入表，但是你需要手动挨个导入函数，编写函数指针来调用函数。

虚荣的倒影 2022/7/12 23:23:56
    lib 是静态编译用的嘛?

0xAA55 姐介 2022/7/12 23:24:11
    不是
    是“DLL附赠的LIB”
    是一种特殊 lib
    静态 lib 虽然也是 lib，但静态 lib 包含了一堆 obj 里面提供了函数的实现等。


虚荣的倒影 2022/7/12 23:24:42
    那把dll嵌入到程序里作为资源是咋整...

0xAA55 姐介 2022/7/12 23:24:59
    动态 lib 则只是提供导入表，从特定DLL导入符号。

虚荣的倒影 2022/7/12 23:25:00
    我擦, lib还有两种lib

0xAA55 姐介 2022/7/12 23:25:20
    图: 5-dll关于lib的导入表
    像这样使用 EXE 查看工具看到的导入信息就是导入表。

虚荣的倒影 2022/7/12 23:25:26
    嗯呐

0xAA55 姐介 2022/7/12 23:25:34
    就是使用“动态lib”的时候会有的。

0xAA55 姐介 2022/7/12 23:26:31
    回复: "那把dll嵌入到程序里作为资源是咋整..."
    dll 嵌入程序里作为资源，这个本质上和你程序用一个字节数组把一个压缩了的 dll的二进制码写到代码里，然后通过写文件、解压的方式生成 dll 的道理是一样的，属于“必被杀毒软件干掉”的行为。

虚荣的倒影 2022/7/12 23:27:56
    咳咳..这还是非正规操作啊
    那意思就是, "动态lib" 用来在调用外部dll时候, ,免去loadlibrary并getprocaddress赋值函数指针这个步骤是吗
    话说, gcc与msvc生成的 静态lib 是不是通用的呢
    这样整的话, 岂不是比中间文件方便一点    

0xAA55 姐介 2022/7/13 0:11:22
    回复: "gcc与msvc生成的 静态lib 是不是通用的呢"
    不通用，各自用各自的格式，重点是 C++ 符号修饰规则根本就不统一

    回复: "这样整的话, 岂不是比中间文件方便一点"
    lib 可以被理解为“一堆中间文件打了个压缩比率为零的zip”

    你现在了解了传统的编译原理

0xAA55 姐介 2022/7/13 0:23:01
    明天教你黑科技：    
    基于字节码的跨编译单元内联函数的实现
    链接时间代码生成